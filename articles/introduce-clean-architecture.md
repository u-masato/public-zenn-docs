---
title: "クリーンアーキテクチャに入門する"
emoji: "🏡"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["cleanarchitecture"]
published: false
---

## はじめに

クリーンアーキテクチャは、ソフトウェアの設計において非常に重要な考え方です。近年のソフトウェア開発ではこのアーキテクチャの理解が欠かせません。
本記事では、レイヤードアーキテクチャやヘキサゴナルアーキテクチャについて解説し、クリーンアーキテクチャの理解を深めていきます。

## なぜアーキテクチャについて学ぶのか

ソフトウェアのアーキテクチャとは、ソフトウェアの全体の構造とその構成要素の関係を指します。

通常のWebアプリケーションなどのソフトウェア開発は、ひとりで完結するものではなく、チームで継続的に改善していくものです。

良いアーキテクチャを選んでも、直接的に新しい機能が増えるわけではありませんが、
継続的に開発を続けるには、コードが分かりやすく、修正しやすい状態であることが望ましいです（保守容易性）。

アーキテクチャを考えずに成長したソフトウェアは、まるで巨大な泥団子のようになり、少しの修正でも多くの影響が出てしまい、変更が難しくなります。
このような状態になると、新しく参加した開発者が理解しにくくなり、開発のスピードが落ち、不満が溜まっていきます。最終的には誰も触りたくないソフトウェアになってしまいます。

良いソフトウェアの構造を保つことは、開発者が機能の追加や修正を簡単にできるようし、結果としてユーザーに早く価値を届けられるようになります。

## 依存関係について理解する

アーキテクチャを理解するためには、まず「依存関係」について知ることが大切です。プログラムを書く上でも、依存関係を理解することは非常に重要です。

依存関係とは、あるコンポーネントが他のコンポーネントに依存している状態を意味します。依存先が変更された場合、依存元はその影響を受けることになります。
（コンポーネントとは、クラスやモジュールなど、プログラムを構成する塊のことです）

![依存関係図](/images/introduce-clean-architecture/dependency.png =500x)
*コンポーネント依存関係の例*

図のように、コンポーネントCがコンポーネントDに依存している場合、Dに変更があるとCにも影響が出ます。
コンポーネントAは、BとCに依存していて、間接的にDにも依存しています。
コンポーネントBとDは、どのコンポーネントにも依存していない（独立している）ため、比較的安定しています。

ソフトウェアのコンポーネントが多くの他コンポーネントに依存していると、変更が困難になります。
安定したコンポーネントより、不安定なコンポーネントに依存した方が、コンポーネントの安定性が下がります。

ソフトウェア開発において、依存関係を完全に無くすことはできません。しかし、どのように依存関係を構築するかを理解し、管理することが、ソフトウェアの安定性と保守性を高めるために重要です。

ここで説明している依存には、汎化や合成、集約なども含んでいます。

## クリーンアーキテクチャとは

[クリーンアーキテクチャ](https://blog.tai2.net/the_clean_architecture.html)は、Robert C. Martin氏（通称ボブおじさん）によって提唱されたアーキテクチャです。

ボブおじさんは、アーキテクチャの目的をソフトウェアシステムの開発・デプロイ・運用・保守を容易にし、最終的な目的は、システムのライフタイムコストを最小限に抑え、プログラマの生産性を最大にすること、としています。

多くのアーキテクチャは、**関心の分離**という共通の目的をもっています。
関心の分離とは、異なる役割や責任を持つ部分を分けることで、変更の影響を最小限に抑えることを指します。

これを実現するために、ソフトウェアをレイヤー（層）に分けます。（関心は例えば、UI、ビジネスルール、データベース、外部サービスとの通信になります）

クリーンアーキテクチャは、これらのアイデアを一般化し、どのように設計すべきかのガイドラインを提供する概念です。ただし、具体的な実装を強制するものではなく、柔軟に適用できるのが特徴です。

## レイヤードアーキテクチャ

クリーンアーキテクチャを理解するための基本として、まずは「レイヤードアーキテクチャ」について学びましょう。
これは、ソフトウェアを関心ごとに分けた構造の一つで、一般的には3つのレイヤーで構成されています。
つまり、プレゼンテーション層、ビジネスロジック層、データアクセス層です。
![レイヤードアーキテクチャの図](/images/introduce-clean-architecture/N-layer-archtecture.png)

レイヤードアーキテクチャに何層までという決まりはありません。関心ごとによってレイヤーを分けることと、依存のルールを守ることが重要です。

### プレゼンテーション層

プレゼンテーション層は、エンドユーザーと直接対話する部分を担当します。例えば、WebアプリケーションのGUI（グラフィカルユーザーインターフェース）やCLI（コマンドラインインターフェース）などがこれに該当します。
この層は、外部からのリクエストを受け取り、その結果をユーザーに返す役割を持ちます。
プレゼンテーション層はソフトウェアの公開インターフェースです。

### ビジネスロジック層

ビジネスロジック層は、ソフトウェアの「心臓部」であり、企業のビジネスルールをカプセル化しています。この層は、外部の変更による影響を受けにくい部分であり、ソフトウェアのコアな機能を提供します。
例えば、銀行アプリケーションでの口座間の資金移動のロジックはこの層に含まれます。

### データアクセス層

データアクセス層は、データの永続化を提供するレイヤーです。
データベースやファイルシステム、あるいは外部サービスにデータを保存・取得する機能を提供します。
この層は、ビジネスロジック層が具体的なデータ保存方法に依存しないようにするためのカプセル化を行います。

### レイヤードアーキテクチャの問題点

レイヤードアプリケーションでは、上のレイヤーは直下のレイヤーにのみ依存します。

例えば、ビジネスロジック層はデータアクセス層に依存しますが、その逆は許されません。
このルールを守ることで、各レイヤー間の独立性が保たれ、変更の影響を最小限に抑えることができます。

しかし、このアーキテクチャには、ビジネスロジック層がデータアクセス層に依存してしまうという課題があります。
例えば、データベースに依存していると、データベースの変更がビジネスロジックに大きな影響を与えてしまいます。

このアーキテクチャでは、ビジネスロジックがデータベースなどの技術に依存することになり、データアクセス層ができるまでビジネスロジックが実装できなかったり、ビジネスロジックのテストが面倒になる問題があります。データアクセス層が外部サービスとの通信だったりすると、テストは難しくなります。

書籍や記事によって、以下の用語で表現されることがあります。

- プレゼンテーション層 = ユーザーインターフェース層
- サービス層 = アプリケーション層
- ビジネスロジック層 = ドメイン層
- データアクセス層 = インフラストラクチャ層 = 永続化層

## ヘキサゴナルアーキテクチャ

次に、レイヤードアーキテクチャの課題を解決するために提案された「ヘキサゴナルアーキテクチャ」について学びましょう。これは、Alistair Cockburn氏によって提唱されたアーキテクチャで、別名「ポート・アダプタアーキテクチャ」とも呼ばれます。

レイヤードアーキテクチャの欠点を解消し、ビジネスロジックを中心として依存関係を構築する構造になっています。
![ヘキサゴナルアーキテクチャの図](/images/introduce-clean-architecture/hexagonal-architecture.png)

## 基本概念

レイヤードアーキテクチャと同じで、関心毎にレイヤーで分離されています。
ヘキサゴナルアーキテクチャでは、ビジネスロジックを中心に置き、その周りに「ポート」と「アダプタ」を配置します。これにより、ビジネスロジックが外部システムに直接依存しない構造を作ります。
![ヘキサゴナルアーキテクチャのレイヤー](/images/introduce-clean-architecture/hexagonal-architecture-leyer.png =300x)
*ヘキサゴナルアーキテクチャのレイヤー図*

## ポートとアダプタ

ポートは、ビジネスロジックが外部システムと通信するための**インターフェース**です。具体的な処理をビジネスロジックから切り離し、どのように外部とやり取りするかを定義します。これにより、ビジネスロジックがどのような技術に依存するかを知らずに済むようになります。

アダプタは、ポートで定義されたインターフェースを**実装**する具体的なコンポーネントです。例えば、データベースとのやり取りや、ユーザーインターフェースとの連携を行う部分です。アダプタを変更することで、異なるデータベースやUIに対応することが容易になります。

## 依存性注入（Dependency Injection: DI）

データアクセス層がアプリケーション層に依存するようになっていますが、しかしアプリケーションの中でデータアクセスロジックを呼び出すのでそのままではデータアクセス層に依存してしまいます。どのようにして依存関係を逆にするのでしょうか。
ここで使われるのが、依存性注入（Dependency Injection: DI）のテクニックです。

DIが使われているのが、図のポートとアダプタの部分です。
ビジネスロジックがどのアダプタを使用するかを外部から注入します。これにより、ビジネスロジックは外部の詳細を知らずに、ポートを通じて必要な機能を呼び出すことができます。

ポートはアプリケーション層にあり、アダプタはインフラストラクチャ層にあります。
アプリケーション層のサービスがインターフェースであるポートに依存し、インフラストラクチャ層のアダプタがポートを実装すると、インフラストラクチャ層がアプリケーション層に依存するようになり、依存方向を逆転できます。

![依存性注入の図](/images/introduce-clean-architecture/hexagonal-architecture-dependency.png)
*依存性注入の図*

例えば、あるアプリケーションがユーザー情報を保存する機能を持っているとします。この保存先が、データベースかファイルシステムかに関わらず、ビジネスロジックはその詳細を知る必要がありません。DIを使って、どのアダプタを使用するかを指定することで、ビジネスロジックはそのままのコードで動作します。

これにより、開発者はテスト時にデータベースを使わず、モックオブジェクト（擬似的なオブジェクト）を使用してテストを行うことができるため、テストの効率が大幅に向上します。

こちらも書籍や記事によって、以下の用語で表現されることがあります。

- アプリケーション層 = サービス層 = ユースケース層
- ビジネスロジック = ドメイン層 = コア層

## クリーンアーキテクチャ

最後に、クリーンアーキテクチャについて学びましょう。これは、ヘキサゴナルアーキテクチャやオニオンアーキテクチャなど、様々なアーキテクチャのアイデアを統合し、一般化したものです。

クリーンアーキテクチャの中心的な考え方は、関心ごとを分離し、依存関係をビジネスロジックに向けることです。

これらのアーキテクチャは、以下のような特性のシステムを生み出します。

1. フレームワークに依存しない：ビジネスロジックはフレームワークに依存しないため、フレームワークの変更が用意
1. テスト可能：外部システムに依存しないため、ビジネスロジックのテストが容易
1. UIに依存しない：UIの変更がビジネスロジックに影響を与えません
1. データベースに依存しない： データベースの種類や構造が変更されても、ビジネスロジックには影響しません
1. 外部エージェントに依存しない：外部サービスやライブラリの変更がビジネスロジックに影響を与えません

![クリーンアーキテクチャの図](/images/introduce-clean-architecture/clean-architecture.png)
*クリーンアーキテクチャの概念図「Clean Architecture　達人に学ぶソフトウェアの構造と設計」より*

クリーンアーキテクチャでは、中心にビジネスルールがあり、外側に技術的な関心（UI、データベースなど）が配置されています。
円になっていますが、これらは、レイヤードアーキテクチャと同じで、関心毎で分離されています。

外側から矢印が内側に向かっているのは、依存のルールです。
この構造により、ビジネスロジックは外部の技術的な詳細に依存せず、柔軟で保守しやすいシステムを実現します。

エンティティ層は、ソフトウェアの最重要ビジネスルールを含む層。外部の影響を受けずに独立している。

ユースケース層は、インターフェースアダプタ層から受け取ったデータをもとに、エンティティ層のビジネスロジックを組み合わせて、アプリケーション特有のロジックを達成します。
このレイヤーもフレームワークやデータベースなどの外部技術について知りません。

インターフェースアダプタ層は、外部システムと内部システムのデータを変換する層です。
ヘキサゴナルアーキテクチャのアダプタに相当します。

最も外側のフレームワーク・ドライバーレイヤーは、データベースやウェブサーバーなどの外部エージェントとの通信を処理します。これらのレイヤーを独自で実装することは稀で、ライブラリやフレームワークを使うことが多いです。

右下図は、ユースケース層にインターフェース（入力ポートと出力ポート）があり、
入力ポート実装がユースケースに、出力ポートの実装がインターフェースアダプタ層にあります。Flow of Controlの矢印は、実装コンポーネントを呼び出す順序を示しています。
DIを使って、インターフェースアダプタ層がユースケース層に依存することを示しています。

クリーンアーキテクチャは、ビジネスロジックを中心に据え、外部の技術的な関心ごとに依存しない構造を提供します。これにより、システムは柔軟性を持ち、将来の変更にも耐えられる設計が可能になります。

## まとめ

クリーンアーキテクチャを理解し、その概念を実践に取り入れることは、ソフトウェアエンジニアにとって価値のあるスキルです。
特に、DIを使って依存関係を逆転させビジネスロジックを外部から独立した状態に保つように、ソフトウェア設計において依存を正しく制御できるようになると、開発に自信が持てるようになります。

### 参考文献

- [クリーンアーキテクチャ](https://blog.tai2.net/the_clean_architecture.html)
- [Clean Architecture　達人に学ぶソフトウェアの構造と設計](https://www.amazon.co.jp/dp/B07C3N2N2B<https://www.amazon.co.jp/Clean-Architecture-%E9%81%94%E4%BA%BA%E3%81%AB%E5%AD%A6%E3%81%B6%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E3%81%AE%E6%A7%8B%E9%80%A0%E3%81%A8%E8%A8%AD%E8%A8%88-%E3%82%A2%E3%82%B9%E3%82%AD%E3%83%BC%E3%83%89%E3%83%AF%E3%83%B3%E3%82%B4-%EF%BC%B2%EF%BD%8F%EF%BD%82%EF%BD%85%EF%BD%92%EF%BD%94-%EF%BC%A3%EF%BC%8E%EF%BC%AD%EF%BD%81%EF%BD%92%EF%BD%94%EF%BD%89%EF%BD%8E-ebook/dp/B07FSBHS2V/ref=sr_1_1?crid=1M1R49N56AAJY&dib=eyJ2IjoiMSJ9.RJ8-uxVCrwuQjKCWDz1BHuLN7ywG3vWBVvFyLKAyB-Az3s77hsOdVkyqoUaaPKJ_q4TtKSoFocZyN3VJzC8OYL0P2yWzsGtkLcEn_4dYBeWLGiWLdsLKGtp8bzvyLr5cp52L2vKdxHoFAJcPIKQ5_Wt95c7g6R34Z83ebMJ1gkICwPpJ-sldBLHwqAjPfJlVpwFKCSnTFTFRGcJemZbxkNigekxy3XIZHw0u0UX4paU.X0jANgxCAWy3EXo9CAW_YsMmTx04FcqTzksETre87Dc&dib_tag=se&keywords=clean+architecture+%E9%81%94%E4%BA%BA%E3%81%AB%E5%AD%A6%E3%81%B6%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E3%81%AE%E6%A7%8B%E9%80%A0%E3%81%A8%E8%A8%AD%E8%A8%88&qid=1721576592&sprefix=Clean+ar,aps,192&sr=8-1>)

- [手を動かしてわかるクリーンアーキテクチャ　ヘキサゴナルアーキテクチャによるクリーンなアプリケーション開発](https://www.amazon.co.jp/%E6%89%8B%E3%82%92%E5%8B%95%E3%81%8B%E3%81%97%E3%81%A6%E3%82%8F%E3%81%8B%E3%82%8B%E3%82%AF%E3%83%AA%E3%83%BC%E3%83%B3%E3%82%A2%E3%83%BC%E3%82%AD%E3%83%86%E3%82%AF%E3%83%81%E3%83%A3-%E3%83%98%E3%82%AD%E3%82%B5%E3%82%B4%E3%83%8A%E3%83%AB%E3%82%A2%E3%83%BC%E3%82%AD%E3%83%86%E3%82%AF%E3%83%81%E3%83%A3%E3%81%AB%E3%82%88%E3%82%8B%E3%82%AF%E3%83%AA%E3%83%BC%E3%83%B3%E3%81%AA%E3%82%A2%E3%83%97%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E9%96%8B%E7%99%BA-Tom-Hombergs-ebook/dp/B0D9V7Y949/?_encoding=UTF8&pd_rd_w=ly7oA&content-id=amzn1.sym.8ec06bf6-6286-42d1-8a4d-9502351c57b9&pf_rd_p=8ec06bf6-6286-42d1-8a4d-9502351c57b9&pf_rd_r=JZDQRV9478QPX75YK2SC&pd_rd_wg=GxuaE&pd_rd_r=bbd5eb18-2fe5-4740-a167-7ca0ac300899)

- [Go言語で構築するクリーンアーキテクチャ設計](https://www.amazon.co.jp/Go%E8%A8%80%E8%AA%9E%E3%81%A7%E6%A7%8B%E7%AF%89%E3%81%99%E3%82%8B%E3%82%AF%E3%83%AA%E3%83%BC%E3%83%B3%E3%82%A2%E3%83%BC%E3%82%AD%E3%83%86%E3%82%AF%E3%83%81%E3%83%A3%E8%A8%AD%E8%A8%88-%E6%8A%80%E8%A1%93%E3%81%AE%E6%B3%89%E3%82%B7%E3%83%AA%E3%83%BC%E3%82%BA-%E4%B8%8A%E7%94%B0-%E8%A3%95%E8%80%80-ebook/dp/B0D8VGQ3PL/ref=sr_1_2?crid=3UV4THAQ4R1IZ&dib=eyJ2IjoiMSJ9.PB6rXi6Nm4rGw3ihzKiSdleCgy5O190fyd4bZvWUlL1pSthQTTgtliXWGHWYnASDxXFZ7jYm2ibyF6ir9kk2V7w7r26-kr8ZsZxv76lkbyQ.qFY6YvBedLcYJ6Nbvk6qusNwElnlm7-L6JPqVSHO3Gs&dib_tag=se&keywords=%E3%82%AF%E3%83%AA%E3%83%BC%E3%83%B3%E3%82%A2%E3%83%BC%E3%82%AD%E3%83%86%E3%82%AF%E3%83%81%E3%83%A3+go&qid=1721589618&sprefix=%E3%82%AF%E3%83%AA%E3%83%BC%E3%83%B3%E3%82%A2%E3%83%BC%E3%82%AD%E3%83%86%2Caps%2C488&sr=8-2)

- [ドメイン駆動設計をはじめよう ―ソフトウェアの実装と事業戦略を結びつける実践技法](https://www.amazon.co.jp/%E3%83%89%E3%83%A1%E3%82%A4%E3%83%B3%E9%A7%86%E5%8B%95%E8%A8%AD%E8%A8%88%E3%82%92%E3%81%AF%E3%81%98%E3%82%81%E3%82%88%E3%81%86-%E2%80%95%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E3%81%AE%E5%AE%9F%E8%A3%85%E3%81%A8%E4%BA%8B%E6%A5%AD%E6%88%A6%E7%95%A5%E3%82%92%E7%B5%90%E3%81%B3%E3%81%A4%E3%81%91%E3%82%8B%E5%AE%9F%E8%B7%B5%E6%8A%80%E6%B3%95-Vlad-Khononov/dp/481440073X/ref=sr_1_1?crid=1NEAJBHP18FSS&dib=eyJ2IjoiMSJ9.UZGoFI895yynkLeXbLkNJL9cxA1bscHVKfpoU8IrIYGD8EYG9j5wFj8nuMbNf2pNuRsK_X4V8vTM_Zo4c5GcaWysOkI230MwDqh59YQWAuXw7Xa5c-tExHqYNBmxph_M7EphWe31BPxVHrggSmth_MMcizD0IcX4X-QJwIcYB2QdLJW5hD8mW-7W7x7F3U7yaWd7laTqRsPVJ11NXnMTnYQUcUAwtOpcXLInt2ymIUjmvHrtnMKPsmFjOClW6f6cEfNx44r5CMxEUKhULnn3VP_XWY24VLYmx7WFVPawEcM.dPlqUlWC0vfjZ8jwANIFZ3BT4qT_4DDPe96vOEq1Ryo&dib_tag=se&keywords=%E3%83%89%E3%83%A1%E3%82%A4%E3%83%B3%E9%A7%86%E5%8B%95%E8%A8%AD%E8%A8%88&qid=1723933657&sprefix=%E3%83%89%E3%83%A1%E3%82%A4,aps,183&sr=8-1)

<!-- 脚注を書く場所 -->
<!-- [^1]: Clean Architecture　達人に学ぶソフトウェアの構造と設計 第１５章 -->
